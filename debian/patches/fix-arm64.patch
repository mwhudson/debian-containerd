Description: Fixes for arm64
 The arm64 kernel does not support the 'epoll' syscall, so a wrapper to call
 'epoll_wait' instead is required. This patch is a combination of three
 upstream commits:
  - 6299489 move epoll syscall to arch specific to enable containerd run on arm64
  - 7c572f1 archutils: fix build on aarch64
  - 313db3d Correct build flag for arm64
Author: Michael Hudson-Doyle <michael.hudson@ubuntu.com>
Origin: upstream
Forwarded: not-needed
Last-Update: 2016-07-06

--- /dev/null
+++ containerd-0.2.1/archutils/epoll.go
@@ -0,0 +1,19 @@
+// +build linux,!arm64
+
+package archutils
+
+import (
+	"syscall"
+)
+
+func EpollCreate1(flag int) (int, error) {
+	return syscall.EpollCreate1(flag)
+}
+
+func EpollCtl(epfd int, op int, fd int, event *syscall.EpollEvent) error {
+	return syscall.EpollCtl(epfd, op, fd, event)
+}
+
+func EpollWait(epfd int, events []syscall.EpollEvent, msec int) (int, error) {
+	return syscall.EpollWait(epfd, events, msec)
+}
--- /dev/null
+++ containerd-0.2.1/archutils/epoll_arm64.go
@@ -0,0 +1,70 @@
+// +build linux,arm64
+
+package archutils
+
+// #include <sys/epoll.h>
+/*
+int EpollCreate1(int flag) {
+        return epoll_create1(0);
+}
+
+int EpollCtl(int efd, int op,int sfd, int Events, int Fd) {
+        struct epoll_event event;
+        event.events = Events;
+        event.data.fd = Fd;
+
+        return epoll_ctl(efd,op,sfd,&event);
+}
+
+typedef struct Event{
+        uint32_t events;
+        int fd;
+};
+
+struct epoll_event events[128];
+int run_epoll_wait(int fd, struct Event *event) {
+        int n, i;
+        n = epoll_wait(fd, events, 128, -1);
+        for (i = 0; i < n; i++) {
+                event[i].events = events[i].events;
+                event[i].fd = events[i].data.fd;
+        }
+        return n;
+}
+*/
+import "C"
+
+import (
+	"fmt"
+	"syscall"
+	"unsafe"
+)
+
+func EpollCreate1(flag int) (int, error) {
+	fd := int(C.EpollCreate1(0))
+	if fd < 0 {
+		return fd, fmt.Errorf("failed to create epoll, errno is %d", fd)
+	}
+	return fd, nil
+}
+
+func EpollCtl(epfd int, op int, fd int, event *syscall.EpollEvent) error {
+	errno := C.EpollCtl(C.int(epfd), C.int(syscall.EPOLL_CTL_ADD), C.int(fd), C.int(event.Events), C.int(event.Fd))
+	if errno < 0 {
+		return fmt.Errorf("Failed to ctl epoll")
+	}
+	return nil
+}
+
+func EpollWait(epfd int, events []syscall.EpollEvent, msec int) (int, error) {
+	var c_events [128]C.struct_Event
+	n := int(C.run_epoll_wait(C.int(epfd), (*C.struct_Event)(unsafe.Pointer(&c_events))))
+	if n < 0 {
+		return int(n), fmt.Errorf("Failed to wait epoll")
+	}
+	for i := 0; i < n; i++ {
+		events[i].Fd = int32(c_events[i].fd)
+		events[i].Events = uint32(c_events[i].events)
+	}
+	return int(n), nil
+}
--- containerd-0.2.1.orig/supervisor/monitor_linux.go
+++ containerd-0.2.1/supervisor/monitor_linux.go
@@ -5,6 +5,7 @@ import (
 	"syscall"
 
 	"github.com/Sirupsen/logrus"
+	"github.com/docker/containerd/archutils"
 	"github.com/docker/containerd/runtime"
 )
 
@@ -14,7 +15,7 @@ func NewMonitor() (*Monitor, error) {
 		exits:     make(chan runtime.Process, 1024),
 		ooms:      make(chan string, 1024),
 	}
-	fd, err := syscall.EpollCreate1(0)
+	fd, err := archutils.EpollCreate1(0)
 	if err != nil {
 		return nil, err
 	}
@@ -47,7 +48,7 @@ func (m *Monitor) Monitor(p runtime.Proc
 		Fd:     int32(fd),
 		Events: syscall.EPOLLHUP,
 	}
-	if err := syscall.EpollCtl(m.epollFd, syscall.EPOLL_CTL_ADD, fd, &event); err != nil {
+	if err := archutils.EpollCtl(m.epollFd, syscall.EPOLL_CTL_ADD, fd, &event); err != nil {
 		return err
 	}
 	EpollFdCounter.Inc(1)
@@ -67,7 +68,7 @@ func (m *Monitor) MonitorOOM(c runtime.C
 		Fd:     int32(fd),
 		Events: syscall.EPOLLHUP | syscall.EPOLLIN,
 	}
-	if err := syscall.EpollCtl(m.epollFd, syscall.EPOLL_CTL_ADD, fd, &event); err != nil {
+	if err := archutils.EpollCtl(m.epollFd, syscall.EPOLL_CTL_ADD, fd, &event); err != nil {
 		return err
 	}
 	EpollFdCounter.Inc(1)
@@ -82,7 +83,7 @@ func (m *Monitor) Close() error {
 func (m *Monitor) start() {
 	var events [128]syscall.EpollEvent
 	for {
-		n, err := syscall.EpollWait(m.epollFd, events[:], -1)
+		n, err := archutils.EpollWait(m.epollFd, events[:], -1)
 		if err != nil {
 			if err == syscall.EINTR {
 				continue
